<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式总结一 | 清新</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="说起可复用的面向对象软件，我又想起了一句”至理名言”，万物基于MIUI  设计模式就是一套基于面向对象而总结出来的设计范式，它能使代码符合高内聚低耦合的目标。 设计模式的分类：  1.1 单例模式 （Singleton）特点：保证一个类只有一个实例，并提供一个访问它的全局访问点。通常我们可以让一个全局变量来控制对象的访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一">
<meta name="keywords" content="学习笔记,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式总结一">
<meta property="og:url" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;2020&#x2F;0321&#x2F;hexo_design_mode_one&#x2F;index.html">
<meta property="og:site_name" content="清新">
<meta property="og:description" content="说起可复用的面向对象软件，我又想起了一句”至理名言”，万物基于MIUI  设计模式就是一套基于面向对象而总结出来的设计范式，它能使代码符合高内聚低耦合的目标。 设计模式的分类：  1.1 单例模式 （Singleton）特点：保证一个类只有一个实例，并提供一个访问它的全局访问点。通常我们可以让一个全局变量来控制对象的访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
<meta property="og:updated_time" content="2022-07-24T08:26:35.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
	
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
						m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	ga('create', 'UA-160992877-1', 'auto');
	ga('send', 'pageview');
</script>


</head>


<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">野生纯逗</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/simonln/" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAGS</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">设计模式总结一</h2>
  <p class="sub">Mar 21, 2020</p>
  <article class="content">
    <blockquote>
<p>说起可复用的面向对象软件，我又想起了一句”至理名言”，万物基于MIUI</p>
</blockquote>
<p>设计模式就是一套基于面向对象而总结出来的设计范式，它能使代码符合高内聚低耦合的目标。</p>
<p>设计模式的分类：</p>
<p><img src="/images/design_pattern_1.png" alt=""></p>
<h2 id="1-1-单例模式-（Singleton）"><a href="#1-1-单例模式-（Singleton）" class="headerlink" title="1.1 单例模式 （Singleton）"></a>1.1 单例模式 （Singleton）</h2><p><strong>特点</strong>：<br>保证一个类只有一个实例，并提供一个访问它的全局访问点。通常我们可以让一个全局变量来控制对象的访问，但它不能防止你实例化多个对象。一个最好的方法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。<br><strong>应用场景</strong>：<br>a. 当类只能有一个实例而且可以从一个众所周知的访问点访问它时。<br>b.当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。<br><strong>UML图</strong>：<br><img src="/images/design_pattern_2.png" alt=""></p>
<p><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/e06386c912fec8c79458be05d8854575" target="_blank" rel="noopener">Sington.cc</a></p>
<p><strong>优点</strong>：<br>a.对唯一实例受控访问<br>b.缩小命名空间<br>c.允许对操作和表示的精细化<br>d.允许可变数目的实例<br>e.比静态类操作更灵活</p>
<p><strong>缺点</strong>：无</p>
<h2 id="1-2-工厂方法模式（Factory-Method）"><a href="#1-2-工厂方法模式（Factory-Method）" class="headerlink" title="1.2 工厂方法模式（Factory Method）"></a>1.2 工厂方法模式（Factory Method）</h2><p><strong>特点</strong>：<br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。<br><strong>应用场景</strong>：<br>a.当一个类不知道它所必须创建的对象的类的时候<br>b.当一个类希望由它的子类来指定它所创建的对象的时候<br>c.当类将创建对象的职责委托给多个帮助子类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候</p>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern_3.png" alt=""></p>
<p><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/698e6305f2e6da0adc2847e6f54bae8c" target="_blank" rel="noopener">FactoryMethod.cc</a></p>
<p><strong>优点</strong>：<br>a.去除了客户端与具体产品的依赖<br>b.为子类提供挂钩<br>c.连接平行的类层次<br><strong>缺点</strong>：<br>具体产品创建依赖于具体工厂</p>
<h2 id="1-3-抽象工厂模式（Abstract-Factory）"><a href="#1-3-抽象工厂模式（Abstract-Factory）" class="headerlink" title="1.3 抽象工厂模式（Abstract Factory）"></a>1.3 抽象工厂模式（Abstract Factory）</h2><p><strong>特点</strong>：<br>提供一个创建一系列相关或者相互依赖对象的接口，而无需指定具体的类。<br><strong>应用场景</strong>：<br>a.一个系统要独立于它的产品创建、组合和表示时<br>b.一个系统要由多个产品系列中的一个来配置时<br>c.当要强调一系列相关的产品对象的设计以便进行联合使用时<br>d.当提供一个产品类库，而只想显示它们的接口而不是实现时</p>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern_4.png" alt="AbstractFactory"><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/9fb1a85fcd5654780bd6a3ced0eff875" target="_blank" rel="noopener">AbstractFactory.cc</a><br><strong>优点</strong>：<br>a.分离了具体的类<br>b.使得易于交换产品系列<br>c.有利于产品的一致性<br><strong>缺点</strong>：<br>难以支持新种类的产品</p>
<h2 id="1-4-建造者模式（Builder）"><a href="#1-4-建造者模式（Builder）" class="headerlink" title="1.4 建造者模式（Builder）"></a>1.4 建造者模式（Builder）</h2><p><strong>特点</strong>：<br>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。如果我们使用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。<br><strong>应用场景</strong>：<br>a.当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时<br>b.当构造过程必须允许被构造的对象有不同的表示时</p>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern_5.png" alt="Builder"><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/d3ae2c8fd36da6e1f28e4834c1c3dad9" target="_blank" rel="noopener">Builder.cc</a><br><strong>优点</strong>：<br>a.可以改变产品的内部表示<br>b.将构造代码和表示代码分开<br>c.可以对构造过程进行更精细的控制<br><strong>缺点</strong>：<br>暂无</p>
<h2 id="1-5-原型模式（Prototype）"><a href="#1-5-原型模式（Prototype）" class="headerlink" title="1.5 原型模式（Prototype）"></a>1.5 原型模式（Prototype）</h2><p><strong>特点</strong>：<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>应用场景</strong>：<br>a.当一个系统应该独立于它的产品创建、构成和表示时<br>b.当要实例化的实例在运行时刻指定时<br>c.为了避免创建一个与产品类层次平行的工厂类层次时<br>d.当一个类的实例只能有几个不同状态组合中的一种时<br><strong>UML图</strong>：<br><img src="/images/design_pattern_6.png" alt="Prototype"><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/57696fdc0b69ae793e1b11865704d174" target="_blank" rel="noopener">Prototype.cc</a><br><strong>优点</strong>：<br>a.运行时刻增加和删除产品<br>b.改变值以指定新对象<br>c.改变结构以指定新对象<br>d.减少子类的构造<br>e.用类动态配置应用<br><strong>缺点</strong>：<br>每一个Prototype子类都必须实现Clone接口，这对于有的类来说比较困难</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2020/0412/hexo_build_tv_system/" class="link f-fl">⟵点播或直播系统搭建</a>
    
    
      <a href="/2020/0301/hexo_under_panic/" class="link f-fr">疫情之下⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://dribbble.com/" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/simonln/" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>