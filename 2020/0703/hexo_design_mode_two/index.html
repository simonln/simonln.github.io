<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式总结二 | 清新</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="结构型模式主要有：适配器模式，装饰模式，桥接模式，组合模式，享元模式，代理模式，外观模式 2.1 适配器模式 (Adapter)特点： 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 应用场景：  a.使用一个已经存在的类，而它的接口不符合你的需求时  b.当你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接">
<meta name="keywords" content="学习笔记,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式总结二">
<meta property="og:url" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;2020&#x2F;0703&#x2F;hexo_design_mode_two&#x2F;index.html">
<meta property="og:site_name" content="清新">
<meta property="og:description" content="结构型模式主要有：适配器模式，装饰模式，桥接模式，组合模式，享元模式，代理模式，外观模式 2.1 适配器模式 (Adapter)特点： 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 应用场景：  a.使用一个已经存在的类，而它的接口不符合你的需求时  b.当你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
<meta property="og:updated_time" content="2022-07-24T08:26:35.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
	
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
						m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	ga('create', 'UA-160992877-1', 'auto');
	ga('send', 'pageview');
</script>


</head>


<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">野生纯逗</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/simonln/" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAGS</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">设计模式总结二</h2>
  <p class="sub">Jul 3, 2020</p>
  <article class="content">
    <p>结构型模式主要有：适配器模式，装饰模式，桥接模式，组合模式，享元模式，代理模式，外观模式</p>
<h2 id="2-1-适配器模式-Adapter"><a href="#2-1-适配器模式-Adapter" class="headerlink" title="2.1 适配器模式 (Adapter)"></a>2.1 适配器模式 (Adapter)</h2><p><strong>特点</strong>：</p>
<p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.使用一个已经存在的类，而它的接口不符合你的需求时</p>
</li>
<li><p>b.当你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作时</p>
</li>
<li><p>c.想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口（仅适用于对象Adapter）</p>
</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_1.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L2" target="_blank" rel="noopener">Adapter</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.使得可以Adapter可以重定义Adaptee的部分行为</li>
<li>b.允许一个Adapter与多个Adaptee（即Adaptee本身以及它的所有子类）一同工作</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.使用一个具体的类对Adapter类对Adaotee和Target进行匹配，无法灵活使用Adapter的子类</li>
<li>b.使得重定义Adaptee的全部行为比较困难</li>
</ul>
<h2 id="2-2-装饰模式-（Decorator）"><a href="#2-2-装饰模式-（Decorator）" class="headerlink" title="2.2 装饰模式 （Decorator）"></a>2.2 装饰模式 （Decorator）</h2><p><strong>特点</strong>：</p>
<p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</p>
</li>
<li><p>b.处理那些可以撤销的职责</p>
</li>
<li><p>c.当不能采用生成子类的方法进行扩充时</p>
</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_2.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L75" target="_blank" rel="noopener">Decorator</a><br><strong>优点</strong>：</p>
<ul>
<li><p>a.比静态类更灵活</p>
</li>
<li><p>b.避免在层次结构高层的类有太多的特征</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>a.Decorator与它的Component不一样，Decorator只有一个透明的包装</p>
</li>
<li><p>b.当装饰的功能一多时，会有许多小对象</p>
</li>
</ul>
<h2 id="2-3-桥接模式-（Bridge）"><a href="#2-3-桥接模式-（Bridge）" class="headerlink" title="2.3 桥接模式 （Bridge）"></a>2.3 桥接模式 （Bridge）</h2><p><strong>特点</strong>：</p>
<p>将抽象部分与它的实现部分分离，使它们都可以独立的变化。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.不希望在抽象和它的实现部分之间有一个固定的绑定关系</p>
</li>
<li><p>b.类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充</p>
</li>
<li><p>c.对一个抽象的实现部分的修改应对客户不产生影响</p>
</li>
<li><p>d.对客户完全隐藏抽象的实现部分</p>
</li>
<li><p>e.意图在多个对象间共享实现，但同时要求客户并不知道这一点</p>
</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_3.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L156" target="_blank" rel="noopener">Bridge</a><br><strong>优点</strong>：</p>
<ul>
<li><p>a.分离接口及其实现部分</p>
</li>
<li><p>b.提高可扩充性</p>
</li>
</ul>
<ul>
<li>c.实现细节对客户透明</li>
</ul>
<p><strong>缺点</strong>：<br>无</p>
<h2 id="2-4-组合模式-（Composite）"><a href="#2-4-组合模式-（Composite）" class="headerlink" title="2.4 组合模式 （Composite）"></a>2.4 组合模式 （Composite）</h2><p><strong>特点</strong>：</p>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>a.表达对象的部分-整体层次结构</li>
<li>b.希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_4.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L230" target="_blank" rel="noopener">Composite</a><br><strong>优点</strong>：</p>
<ul>
<li><p>a.定义了包含基本对象和组合对象的层次结构</p>
</li>
<li><p>b.简化客户代码</p>
</li>
<li><p>c.使得更容易增加新类型的组件</p>
</li>
<li><p>d.是设计变得更加一般化</p>
</li>
</ul>
<p><strong>缺点</strong>：<br>无</p>
<h2 id="2-5-享元模式-（Flyweight）"><a href="#2-5-享元模式-（Flyweight）" class="headerlink" title="2.5 享元模式 （Flyweight）"></a>2.5 享元模式 （Flyweight）</h2><p><strong>特点</strong>：<br>运用共享技术有效的支持大量细粒度的对象。享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来标识数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。<br><strong>应用场景</strong>：<br>一个应用程序使用了大量的对象，并且大量的对象造成巨大的开销,对象的大多数状态对可变为外部状态，可使用相对较少的共享对象取代很多组对象，不依赖于对象标识，此时可考虑使用享元模式</p>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_5.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L321" target="_blank" rel="noopener">FlyweigthMode</a><br><strong>优点</strong>：<br>节约存储</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>a. 对象太多时，会造成运行时的资源与性能损耗</li>
<li>b.为了使对象共享需要将一些状态外部化，使得程序的逻辑复杂化</li>
</ul>
<h2 id="2-6-代理模式（Proxy）"><a href="#2-6-代理模式（Proxy）" class="headerlink" title="2.6 代理模式（Proxy）"></a>2.6 代理模式（Proxy）</h2><p><strong>特点</strong>：</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>a.远程代理 为一个对象在不同的地址空间提供局部代表</li>
<li>b.虚代理 根据需要创建开销很大的对象</li>
<li>c.保护代理 控制原始对象的访问</li>
<li>d.智能指引 取代了简单的指针，它在访问对象时执行一些附加的操作</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_6.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L392" target="_blank" rel="noopener">ProxyMode</a></p>
<p><strong>优点</strong>：<br>a.远程代理可以隐藏一个对象存在于不同地址空间的事实<br>b.虚代理可以进行最优化，例如根据要求创建对象<br>c.保护代理和只能指引对允许在访问一个对象时有一些附加的内务处理<br><strong>缺点</strong>：<br>无</p>
<h2 id="2-7-外观模式（Facade）"><a href="#2-7-外观模式（Facade）" class="headerlink" title="2.7 外观模式（Facade）"></a>2.7 外观模式（Facade）</h2><p><strong>特点</strong>：<br>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，使得这一子系统更加容易使用</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li>a.当需要为一个复杂的子系统提供一个简单接口时</li>
<li>b.客户程序</li>
</ul>
<p><strong>UML图</strong>：<br><img src="/images/design_pattern2_7.png" alt=""><br><strong>实现</strong>：<br><a href="https://gist.github.com/simonln/b61fafe2f4506d73e1d8352587b6012b#file-structuretypemode-cc-L440" target="_blank" rel="noopener">FacadeMode</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.对客户屏蔽了子系统组件</li>
<li>b.实现了子系统与客户之间的松耦合关系</li>
<li>c.不限制使用子系统类</li>
</ul>
<p><strong>缺点</strong>：<br>需要在系统的通用性和易用性之间做取舍</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2020/0909/hexo_KMP_DFA/" class="link f-fl">⟵KMP算法中的DFA计算</a>
    
    
      <a href="/2020/0520/hexo_FFTW_usage/" class="link f-fr">使用FFTW库⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://dribbble.com/" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/simonln/" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>