<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>排查一个同名函数引发的问题 | 清新</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.前景提要在一次代码安全审计完成后，安全部门提出一个历史遗留问题需要修改。修改的方法也很简单，只需要调用库里的函数判断一下是否有问题即可。库最终会被打包到libcgibase.so中库函数实现如下： &#x2F;&#x2F; 判断zip压缩包中是否存在软链接（注：只有确认有软链接才返回true，包括异常在内的其它情况均返回false） bool is_symlink_in_zip(const char *path)">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="排查一个同名函数引发的问题">
<meta property="og:url" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;2022&#x2F;0417&#x2F;hexo_same_file&#x2F;index.html">
<meta property="og:site_name" content="清新">
<meta property="og:description" content="1.前景提要在一次代码安全审计完成后，安全部门提出一个历史遗留问题需要修改。修改的方法也很简单，只需要调用库里的函数判断一下是否有问题即可。库最终会被打包到libcgibase.so中库函数实现如下： &#x2F;&#x2F; 判断zip压缩包中是否存在软链接（注：只有确认有软链接才返回true，包括异常在内的其它情况均返回false） bool is_symlink_in_zip(const char *path)">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;c++_0.png">
<meta property="og:updated_time" content="2022-07-24T08:26:35.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;c++_0.png">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
	
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
						m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	ga('create', 'UA-160992877-1', 'auto');
	ga('send', 'pageview');
</script>


</head>


<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">野生纯逗</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/simonln/" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAGS</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">排查一个同名函数引发的问题</h2>
  <p class="sub">Apr 17, 2022</p>
  <article class="content">
    <h3 id="1-前景提要"><a href="#1-前景提要" class="headerlink" title="1.前景提要"></a>1.前景提要</h3><p>在一次代码安全审计完成后，安全部门提出一个历史遗留问题需要修改。修改的方法也很简单，只需要调用库里的函数判断一下是否有问题即可。库最终会被打包到libcgibase.so中<br>库函数实现如下：</p>
<pre><code class="C++">// 判断zip压缩包中是否存在软链接（注：只有确认有软链接才返回true，包括异常在内的其它情况均返回false）
bool is_symlink_in_zip(const char *path)
{
    if (!path) {
        return false;
    }

    string cmd = &quot;&quot;;
    string result = &quot;&quot;;
    bool ret = false;
    // unzip -Z -l跟ls -l类似，如果有软链接，则会有lrwxrwxrwx之类的以l开头的文件属性。
    ret = sprintf(cmd, &quot;unzip -Z -l %s 2&gt;/dev/null | tail -n +3 | grep &#39;^l&#39; | wc -l&quot;, safeArg(path).c_str());
    if (ret == false) {
        return false;
    }
    ret = ExecuteShell(cmd.c_str(), result);
    if (ret == false) {
        return false;
    }
    if (result == &quot;0&quot;) {
        return false;
    }
    return true;
}</code></pre>
<h3 id="2-问题复现"><a href="#2-问题复现" class="headerlink" title="2.问题复现"></a>2.问题复现</h3><p>在a.cpp中调用is_symlink_in_zip函数，不管压缩包中是否带有软链接，此函数的返回值都是<strong>true</strong>。<br>通过gdb调试断在 <strong>if(result=”0”)</strong> 这一行，查看各变量结果如下：</p>
<p><img src="/images/same_name_1.png" alt="gdb调试结果"></p>
<p>此时能看到result变量的结果为0， 但是长度为2，最后整个执行流跳到了<strong>return true</strong> 这一行。</p>
<h3 id="3-问题排查"><a href="#3-问题排查" class="headerlink" title="3.问题排查"></a>3.问题排查</h3><p>当时定了好几个排查方向：包括编译器问题、有头文件在全局作用域里实现了string operator==(const char*)的重载 、ExecuteShell函数修改result变量时把它写坏了。</p>
<h4 id="3-1-问题1的排查尝试"><a href="#3-1-问题1的排查尝试" class="headerlink" title="3.1 问题1的排查尝试"></a>3.1 问题1的排查尝试</h4><p>使用干净的编译环境，问题依旧；使用其他版本的编译器，然后在另一个对应的系统中运行，问题也依旧。问题卡住，进行不下去。</p>
<h4 id="3-2-问题2的排查尝试"><a href="#3-2-问题2的排查尝试" class="headerlink" title="3.2 问题2的排查尝试"></a>3.2 问题2的排查尝试</h4><p>使用grep在代码仓库里全局搜索重载符号operator==,  只有Cstring这个类在全局作用域内重载了==操作符，但是result是一个string类型的变量，所以不影响。</p>
<h4 id="3-3-问题3的排查尝试"><a href="#3-3-问题3的排查尝试" class="headerlink" title="3.3 问题3的排查尝试"></a>3.3 问题3的排查尝试</h4><p>刚开始时并没有怀疑ExecuteShell函数的问题，因为b.cpp使用了同一个库(libcgibase.so)里的同一个函数（is_symlink_in_zip），经调试发现b.cpp没有出现上述问题。这时候回顾了一下libcgibase.so的实现cgibase.cpp文件，发现其并没有实现ExecuteShell这个函数，然后再查看了一下a.cpp，发现其实现了一个静态函数ExecuteShell。再去看了看b.cpp文件，发现其也实现了一个静态函数ExecuteShell。这时候已经可以明确了is_symlink_in_zip函数中使用的ExecuteShell其实都是由调用者实现的。</p>
<p>这时候对比一下两个cpp的ExecuteShell函数实现，如下：</p>
<p>a.cpp中的实现</p>
<pre><code class="C++">/*执行shell命令
 *输入pstrShellCommand:要执行的命令
 *输出strShellOut：命令结果
 *成功则返回ture，否则false
 */
 bool ExecuteShell(const char *pstrShellCommand, string &amp;strShellOut)
{
    if(pstrShellCommand == NULL)
        return false;
    strShellOut = &quot;&quot;;
    bool bReadError = false;

    FILE *pShellFile = popen(pstrShellCommand, &quot;r&quot;);
    if (pShellFile == NULL)
    {
        return false;
    }

    while (!feof(pShellFile))
    {
        char szShellOutPut[32];
        memset(szShellOutPut, 0, sizeof(szShellOutPut));
        int ret = fread(szShellOutPut, sizeof(char), sizeof(szShellOutPut), pShellFile);
        if (ret != sizeof(szShellOutPut) &amp;&amp; ferror(pShellFile))
        {
            bReadError = true;
            break;
        }
        strShellOut += szShellOutPut;
    }
    pclose(pShellFile);
    pShellFile = NULL;

    if (bReadError)
    {
        return false;
    }
    else
    {
        //删除最后一个回车符
        if (strShellOut.length() &gt; 0)
        {
            if (strShellOut[strShellOut.length()-1] == &#39;\n&#39;)
            {
                strShellOut[strShellOut.length()-1] = 0;
            }

        }
        return true;
    }
}</code></pre>
<p>b.cpp中的ExecuteShell实现</p>
<pre><code class="C++">bool ExecuteShell(const char *pstrShellCommand, std::string &amp;strShellOut)
{
    assert(pstrShellCommand != NULL);
    strShellOut = &quot;&quot;;

    // 执行Shell命令
    FILE *fShellFile = popen(pstrShellCommand, &quot;r&quot;);
    if (fShellFile == NULL)
    {
        return false;
    }

    // 读取Shell 脚本的输出
    while (!feof(fShellFile))
    {
        char szShellOutPut[32];                                                    
        memset(szShellOutPut, 0, sizeof(szShellOutPut));                          
        size_t ret = fread(szShellOutPut, sizeof(char), sizeof(szShellOutPut) - 1, fShellFile);
        if (ret &lt; sizeof(szShellOutPut)-1 &amp;&amp; ferror(fShellFile))
        {
            // 关闭文件
            pclose(fShellFile);
            return false;
        }
        strShellOut += szShellOutPut;
    }

    // 删除掉最后一个回车符
    if (strShellOut.length() &gt; 0)
    {
        if (strShellOut[strShellOut.length() - 1] == &#39;\n&#39;)
        {
            strShellOut.erase(strShellOut.begin() + strShellOut.length() - 1);
        }
    }

    pclose(fShellFile);
    fShellFile = NULL;
    return true;
}</code></pre>
<p>其他的逻辑大体相同，问题主要出现在删除最后一行回车符这个实现上。<br>a.cpp中的实现是将strShellOut变量最后一个字符改成’\0’，b.cpp中的实现是去除strShellOut变量最后一个回车符。a.cpp实现中的strShellOut变量的size其实没变的。这时候就能解释为啥使用gdb调试的时候result.size()为2，但是其内容为 0 了。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>总结起来就是拿着写c的思维去写c++，问题不大。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2022/0717/hexo_lua_dev/" class="link f-fl">⟵LUA开发那些事</a>
    
    
      <a href="/2022/0109/feeling_read_rural_china/" class="link f-fr">读乡土中国有感⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://dribbble.com/" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/simonln/" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>