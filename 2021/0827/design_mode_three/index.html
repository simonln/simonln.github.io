<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式总结三 | 清新</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这一部分总结一下行为型设计模式中的6个，分别是：观察者模式、模板方法模式、命令模式、状态模式、职责链模式、解释器模式。 3.1 观察者模式 (Observer)特点： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生变更时，所有依赖于它的对象都得到通知并被自动更新 应用场景：  a.当一个抽象模型由两个部分，其中一个部分依赖于另一个部分，而两者又是封装在独立的对象中时  b.当一个对象的改变">
<meta name="keywords" content="学习笔记,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式总结三">
<meta property="og:url" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;2021&#x2F;0827&#x2F;design_mode_three&#x2F;index.html">
<meta property="og:site_name" content="清新">
<meta property="og:description" content="这一部分总结一下行为型设计模式中的6个，分别是：观察者模式、模板方法模式、命令模式、状态模式、职责链模式、解释器模式。 3.1 观察者模式 (Observer)特点： 定义对象间的一种一对多的依赖关系，当一个对象的状态发生变更时，所有依赖于它的对象都得到通知并被自动更新 应用场景：  a.当一个抽象模型由两个部分，其中一个部分依赖于另一个部分，而两者又是封装在独立的对象中时  b.当一个对象的改变">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
<meta property="og:updated_time" content="2022-07-24T08:26:35.796Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
	
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
						m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	ga('create', 'UA-160992877-1', 'auto');
	ga('send', 'pageview');
</script>


</head>


<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">野生纯逗</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/simonln/" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAGS</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">设计模式总结三</h2>
  <p class="sub">Aug 27, 2021</p>
  <article class="content">
    <p>这一部分总结一下行为型设计模式中的6个，分别是：观察者模式、模板方法模式、命令模式、状态模式、职责链模式、解释器模式。</p>
<h2 id="3-1-观察者模式-Observer"><a href="#3-1-观察者模式-Observer" class="headerlink" title="3.1 观察者模式 (Observer)"></a>3.1 观察者模式 (Observer)</h2><p><strong>特点</strong>：</p>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生变更时，所有依赖于它的对象都得到通知并被自动更新</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.当一个抽象模型由两个部分，其中一个部分依赖于另一个部分，而两者又是封装在独立的对象中时</p>
</li>
<li><p>b.当一个对象的改变需要同时改变其他对象时，但又不知道具体有多少对象需要改变时</p>
</li>
<li><p>c.当一个对象必须通知其他对象，而又不能假定其他对象是谁的时候</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern3_1.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L7" target="_blank" rel="noopener">Observer</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.目标和观察者间的抽象耦合。一个目标仅知道它有一系列观察者，但是目标知道任何一个观察者属于哪一类</li>
<li>b.支持“广播”式通信</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.意外的更新。观察者间互相之间无感知，但可能会对同一资源有依赖，目标发生更新时可能会造成错误的更新</li>
</ul>
<h2 id="3-2-模板方法模式-Template-method"><a href="#3-2-模板方法模式-Template-method" class="headerlink" title="3.2 模板方法模式 (Template method)"></a>3.2 模板方法模式 (Template method)</h2><p><strong>特点</strong>：</p>
<p>通过把不变行为搬移到超类，去除子类中的重复代码来体现优势</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.一次性实现算法的不变部分，并将可变的行为留给子类来实现</p>
</li>
<li><p>b.各子类的公共行为提取出来并集中到一个公共的父类中以避免代码重复</p>
</li>
<li><p>c.当需要控制子类扩展时</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p><img src="/images/design_pattern3_2.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L114" target="_blank" rel="noopener">Template</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.使子类摆脱重复的不变行为的纠缠</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.无</li>
</ul>
<h2 id="3-3-命令模式-Command"><a href="#3-3-命令模式-Command" class="headerlink" title="3.3 命令模式 (Command)"></a>3.3 命令模式 (Command)</h2><p><strong>特点</strong>：</p>
<p>将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.抽象出待执行的动作以参数化某对象</p>
</li>
<li><p>b.在不同的时刻指定、排列和执行请求</p>
</li>
<li><p>c.支持取消操作</p>
</li>
<li><p>d.支持修改日志</p>
</li>
<li><p>e.使用一系列不可分割的操作作为集合构建一个系统时。比如数据库中的事务系统</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p><img src="/images/design_pattern3_3.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L177" target="_blank" rel="noopener">Command</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.将对象的调用者和对象的构建者进行解耦</li>
<li>b.将命令操作进行对象化，这样就可以和其他对象一样被操控和扩展</li>
<li>c.可将多个命令进行组合</li>
<li>d.增加新的命令很容易，因为无需改变已有的类</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.无</li>
</ul>
<h2 id="3-4-状态模式-State"><a href="#3-4-状态模式-State" class="headerlink" title="3.4 状态模式 (State)"></a>3.4 状态模式 (State)</h2><p><strong>特点</strong>：</p>
<p>主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把负责的判断逻辑简化</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.一个对象的行为取决于它的状态，并且它必须运行时刻根据状态改变它的行为</p>
</li>
<li><p>b.一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p><img src="/images/design_pattern3_4.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L244" target="_blank" rel="noopener">State</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.将与特定状态相关的行为局部化，并且将不同状态的行为分割开来</li>
<li>b.使得状态转换显式化</li>
<li>c.State对象可被共享</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.无</li>
</ul>
<h2 id="3-5-职责链模式-Chain-of-responsibility"><a href="#3-5-职责链模式-Chain-of-responsibility" class="headerlink" title="3.5 职责链模式 (Chain of responsibility)"></a>3.5 职责链模式 (Chain of responsibility)</h2><p><strong>特点</strong>：</p>
<p>多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。接收者和发送者都没有对方明确的消息，且链中的对象自己也并不知道链的结构，结果是职责链可简化对象的相互连接，他们仅需要保持一个指向其后继者的引用，而不需要保持它所有的候选接收者的引用</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.有多个对象可以处理一个请求，具体哪个对象处理该请求在运行时刻自动确定</p>
</li>
<li><p>b.想在不明确接收者的情况下，向多个对象中的一个提交一个请求时</p>
</li>
<li><p>c.可处理一个请求的对象集合需要动态指定时</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p><img src="/images/design_pattern3_5.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L335" target="_blank" rel="noopener">Chain of responsibility</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.降低耦合度</li>
<li>b.增强了给对象指派职责的灵活性</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.不保证接受。可能存在没有任何一个对象处理该请求</li>
</ul>
<h2 id="3-6-解释器模式-Interpreter"><a href="#3-6-解释器模式-Interpreter" class="headerlink" title="3.6 解释器模式 (Interpreter)"></a>3.6 解释器模式 (Interpreter)</h2><p><strong>特点</strong>：</p>
<p>如果一个特定类型的问题发生的频率足够高，那么可能就值得将问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子的问题来解决该问题。</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.对于复杂的文法，抽象出来的文法比较简单时</p>
</li>
<li><p>b.效率不是一个关键问题时</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p><img src="/images/design_pattern3_6.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L439" target="_blank" rel="noopener">Interpreter</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.易于改变和扩展文法。因为该模式使用类来表示文法规则，你可以使用继承来改变和扩展该文法</li>
<li>b.易于实现文法。因为定义抽象语法树中各节点的类的实现大体类似</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.包含许多规则的文法难以管理和维护。文法中的每一条规则至少定义了一个类，当文法复杂时，各类就错综复杂了</li>
</ul>

  </article>
  <footer class="f-cf">
    
      <a href="/2021/0828/hexo_design_mode_four/" class="link f-fl">⟵设计模式总结四</a>
    
    
      <a href="/2021/0613/hexo_to_action/" class="link f-fr">将hexo博客由本地迁移到GitHub Actions⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://dribbble.com/" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/simonln/" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>