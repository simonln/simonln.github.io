<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式总结四 | 清新</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这一部分总结一下行为型设计模式中的5个，分别是：中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式 4.1 中介者模式 (Mediator)特点： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 应用场景：  a.一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解  b.想定制一个分布在">
<meta name="keywords" content="学习笔记,基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式总结四">
<meta property="og:url" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;2021&#x2F;0828&#x2F;hexo_design_mode_four&#x2F;index.html">
<meta property="og:site_name" content="清新">
<meta property="og:description" content="这一部分总结一下行为型设计模式中的5个，分别是：中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式 4.1 中介者模式 (Mediator)特点： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互 应用场景：  a.一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解  b.想定制一个分布在">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
<meta property="og:updated_time" content="2022-07-24T08:26:35.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;www.qingxin.org&#x2F;images&#x2F;design_pattern_0.jpg">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
	
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
						m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	
	ga('create', 'UA-160992877-1', 'auto');
	ga('send', 'pageview');
</script>


</head>


<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">野生纯逗</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/simonln/" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAGS</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">设计模式总结四</h2>
  <p class="sub">Aug 28, 2021</p>
  <article class="content">
    <p>这一部分总结一下行为型设计模式中的5个，分别是：中介者模式、访问者模式、策略模式、备忘录模式、迭代器模式</p>
<h2 id="4-1-中介者模式-Mediator"><a href="#4-1-中介者模式-Mediator" class="headerlink" title="4.1 中介者模式 (Mediator)"></a>4.1 中介者模式 (Mediator)</h2><p><strong>特点</strong>：</p>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解</p>
</li>
<li><p>b.想定制一个分布在多个类中的行为，而又不想生成太多子类</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern4_1.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L601" target="_blank" rel="noopener">Mediator</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.减少了子类的生成</li>
<li>b.简化了对象协议</li>
<li>c.对对象如何协作进行了抽象</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.使控制集中化，于是就把交互复杂性变为了中介者的复杂性</li>
</ul>
<h2 id="4-2-访问者模式-Visitor"><a href="#4-2-访问者模式-Visitor" class="headerlink" title="4.2 访问者模式 (Visitor)"></a>4.2 访问者模式 (Visitor)</h2><p><strong>特点</strong>：</p>
<p>表示一个作用于某对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作</p>
</li>
<li><p>b.需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免这些操作“污染”这些对象的类</p>
</li>
<li><p>c.定义对象结构的类很少改变，但经常需要在此结构上定义新的操作</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern4_2.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L701" target="_blank" rel="noopener">Visitor</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li>a.易于增加新的操作</li>
<li>b.集中了相关的操作而分离了无关的操作</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>a.增加新的数据结构比较困难</li>
</ul>
<h2 id="4-3-策略模式-Strategy"><a href="#4-3-策略模式-Strategy" class="headerlink" title="4.3 策略模式 (Strategy)"></a>4.3 策略模式 (Strategy)</h2><p><strong>特点</strong>：</p>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法</p>
</li>
<li><p>b.需要使用一个算法的不同变体</p>
</li>
<li><p>c.算法使用客户不应该知道的数据</p>
</li>
<li><p>d.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern4_3.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L845" target="_blank" rel="noopener">Strategy</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li><p>a.一个替代继承的方法</p>
</li>
<li><p>b.消除了一些条件语句</p>
</li>
<li><p>c.策略模式可以提供相同行为的不同实现</p>
</li>
<li><p>d.</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>a.使用的客户必须了解不同的策略</p>
</li>
<li><p>b.Strategy和Context之间的通信开销</p>
</li>
<li><p>d.增加了对象的数目</p>
</li>
</ul>
<h2 id="4-4-备忘录模式-Memento"><a href="#4-4-备忘录模式-Memento" class="headerlink" title="4.4 备忘录模式 (Memento)"></a>4.4 备忘录模式 (Memento)</h2><p><strong>特点</strong>：</p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后可将该对象恢复到原先保存的状态</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态</p>
</li>
<li><p>b.如果用一个接口让其他对象直接得到这些状态，将会暴露对象的实现细节并破环对象的封装性</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern4_4.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L925" target="_blank" rel="noopener">Memento</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li><p>a.保持封装的边界。把复杂的对象内部信息对其他的对象屏蔽起来</p>
</li>
<li><p>b.简化了Originator的设计</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>a.代价可能会很高。如果Originator在生成备忘录时必须拷贝并储存大量信息或者客户频繁创建备忘录和恢复Originator的状态，可能会导致非常大的开销</p>
</li>
<li><p>b.在一些语言中可能难以保证只有Originator可以访问备忘录的状态</p>
</li>
<li><p>c.维护备忘录的潜在代价可能会很大</p>
</li>
</ul>
<h2 id="4-5-迭代器模式-Iterator"><a href="#4-5-迭代器模式-Iterator" class="headerlink" title="4.5 迭代器模式 (Iterator)"></a>4.5 迭代器模式 (Iterator)</h2><p><strong>特点</strong>：</p>
<p>提供一种方法顺序访问一个聚合对象中各个元素，而不需要暴露该对象的内部表示</p>
<p><strong>应用场景</strong>：</p>
<ul>
<li><p>a.访问一个聚合对象的内容而无需暴露它的内部表示</p>
</li>
<li><p>b.支持对聚合对象的多种遍历</p>
</li>
<li><p>c.为遍历不同的聚合结构提供一个统一的接口</p>
</li>
</ul>
<p><strong>UML图</strong>：</p>
<p> <img src="/images/design_pattern4_5.png" alt=""></p>
<p><strong>实现</strong>：</p>
<p><a href="https://gist.github.com/simonln/190523360d31315984b6bf53aa658d79#file-behavioraltypemode-cc-L1000" target="_blank" rel="noopener">Memento</a></p>
<p><strong>优点</strong>：</p>
<ul>
<li><p>a.它支持以不同的方法遍历一个聚合</p>
</li>
<li><p>b.简化了聚合类的接口</p>
</li>
<li><p>c.在同一个聚合类上可以有多个遍历</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>无</li>
</ul>

  </article>
  <footer class="f-cf">
    
      <a href="/2022/0109/feeling_read_rural_china/" class="link f-fl">⟵读乡土中国有感</a>
    
    
      <a href="/2021/0827/design_mode_three/" class="link f-fr">设计模式总结三⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  
  
    
      
        · <a href="https://dribbble.com/" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/sakurahams/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/simonln/" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>